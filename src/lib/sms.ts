import { formatPhoneForSMS } from "@/lib/phone";

export interface SmsSendResult {
  ok: boolean;
  message?: string;
  code?: string;
  mocked?: boolean;
  statusCode?: number;
}

export async function sendOTP(phoneNumber: string, code?: string): Promise<SmsSendResult> {
  const apiKey = process.env.MELIPAYAMAK_API_KEY;
  
  // Format phone for Melipayamak API
  const formattedPhone = formatPhoneForSMS(phoneNumber);
  
  console.log("[SMS DEBUG] API Key present:", !!apiKey);
  console.log("[SMS DEBUG] API Key length:", apiKey?.length || 0);
  console.log("[SMS DEBUG] Original phone:", phoneNumber);
  console.log("[SMS DEBUG] Formatted phone:", formattedPhone);
  console.log("[SMS DEBUG] NODE_ENV:", process.env.NODE_ENV);

  if (!apiKey) {
    if (process.env.NODE_ENV !== "production") {
      const mockCode = code || Math.floor(100000 + Math.random() * 900000).toString();
      console.warn(`[SMS MOCK] OTP for ${formattedPhone}: ${mockCode}`);
      return { ok: true, mocked: true, message: "SMS mock logged", code: mockCode, statusCode: 200 };
    }
    return { ok: false, message: "Melipayamak API key not configured", statusCode: 500 };
  }

  // Extra sanity checks for API key format (should be 32+ hex-like chars per dashboard example)
  if (apiKey === "your_api_key_here") {
    console.warn("[SMS DEBUG] Using placeholder API key. Update MELIPAYAMAK_API_KEY in .env and restart the server.");
  }

  const url = `https://console.melipayamak.com/api/send/otp/${apiKey}`;
  const payload = { to: formattedPhone };
  
  console.log("[SMS DEBUG] Request URL:", url);
  console.log("[SMS DEBUG] Request payload:", JSON.stringify(payload));

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
      },
      body: JSON.stringify(payload),
    });

    console.log("[SMS DEBUG] Response status:", response.status);
    console.log("[SMS DEBUG] Response headers:", Object.fromEntries(response.headers.entries()));

    // Robust body parsing (JSON or plain text)
    const contentType = response.headers.get("content-type") || "";
    let data: any = null;
    let rawBody = "";
    try {
      rawBody = await response.text();
      if (contentType.includes("application/json")) {
        data = JSON.parse(rawBody);
      } else {
        // Try JSON parse anyway; if fails keep as text
        try {
          data = JSON.parse(rawBody);
        } catch (_) {
          data = { status: rawBody };
        }
      }
    } catch (parseErr) {
      console.warn("[SMS DEBUG] Failed to read/parse response body:", parseErr);
      data = { status: "<unreadable body>" };
    }

    console.log("[SMS DEBUG] Response body:", typeof data === "string" ? data : JSON.stringify(data, null, 2));

    if (response.ok && data && data.code) {
      console.log("[SMS DEBUG] Success - Melipayamak generated code:", data.code);
      return {
        ok: true,
        message: "OTP sent successfully",
        code: data.code,
        statusCode: response.status,
      };
    } else {
      console.log("[SMS DEBUG] Failed - Response:", data);
      const message = (data && (data.status || data.message)) || `Failed to send OTP (Status: ${response.status})`;
      return {
        ok: false,
        message,
        statusCode: response.status,
      };
    }
  } catch (error) {
    console.error("[SMS DEBUG] Melipayamak OTP API error:", error);
    return { ok: false, message: "SMS service unavailable", statusCode: 502 };
  }
}

export async function sendOtpSms(phone: string, otp: string, purpose: string): Promise<SmsSendResult> {
  const method = process.env.MELIPAYAMAK_OTP_METHOD || "dedicated";
  console.log("[SMS DEBUG] Using method:", method);
  
  let result: SmsSendResult;
  if (method === "shared") {
    // For shared method, we expect the code to be generated by the caller
    if (!otp) {
      return { ok: false, message: "Code required for shared method", statusCode: 400 };
    }
    result = await sendOTPShared(phone, otp);
  } else {
    // For dedicated method, Melipayamak generates the code
    result = await sendOTP(phone);
  }
  
  // If we got a code from Melipayamak, we should store it instead of our generated one
  if (result.ok && result.code && !result.mocked) {
    // Update the OTP in database with the code from Melipayamak
    // This would require updating the otp.ts file to handle external codes
    console.log(`Melipayamak generated code: ${result.code} for ${phone}`);
  }
  
  return result;
}

export async function sendOTPShared(phoneNumber: string, code: string): Promise<SmsSendResult> {
  const apiKey = process.env.MELIPAYAMAK_API_KEY;
  const bodyId = process.env.MELIPAYAMAK_BODY_ID;
  
  // Format phone for Melipayamak API
  const formattedPhone = formatPhoneForSMS(phoneNumber);
  
  console.log("[SMS SHARED DEBUG] API Key present:", !!apiKey);
  console.log("[SMS SHARED DEBUG] Body ID:", bodyId);
  console.log("[SMS SHARED DEBUG] Original phone:", phoneNumber);
  console.log("[SMS SHARED DEBUG] Formatted phone:", formattedPhone);
  console.log("[SMS SHARED DEBUG] Generated code:", code);
  console.log("[SMS SHARED DEBUG] NODE_ENV:", process.env.NODE_ENV);

  if (!apiKey || !bodyId) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`[SMS SHARED MOCK] OTP for ${formattedPhone}: ${code}`);
      return { ok: true, mocked: true, message: "SMS shared mock logged", code, statusCode: 200 };
    }
    return { ok: false, message: "Melipayamak API key or body ID not configured", statusCode: 500 };
  }

  const url = `https://console.melipayamak.com/api/send/shared/${apiKey}`;
  const payload = { bodyId: parseInt(bodyId, 10), to: formattedPhone, args: [code] };
  
  console.log("[SMS SHARED DEBUG] Request URL:", url);
  console.log("[SMS SHARED DEBUG] Request payload:", JSON.stringify(payload));

  try {
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json",
      },
      body: JSON.stringify(payload),
    });

    console.log("[SMS SHARED DEBUG] Response status:", response.status);
    console.log("[SMS SHARED DEBUG] Response headers:", Object.fromEntries(response.headers.entries()));

    // Robust body parsing (JSON or plain text)
    const contentType = response.headers.get("content-type") || "";
    let data: any = null;
    let rawBody = "";
    try {
      rawBody = await response.text();
      if (contentType.includes("application/json")) {
        data = JSON.parse(rawBody);
      } else {
        // Try JSON parse anyway; if fails keep as text
        try {
          data = JSON.parse(rawBody);
        } catch (_) {
          data = { status: rawBody };
        }
      }
    } catch (parseErr) {
      console.warn("[SMS SHARED DEBUG] Failed to read/parse response body:", parseErr);
      data = { status: "<unreadable body>" };
    }

    console.log("[SMS SHARED DEBUG] Response body:", typeof data === "string" ? data : JSON.stringify(data, null, 2));

    // Shared API returns recId on success, not a code
    if (response.ok && data && data.recId) {
      console.log("[SMS SHARED DEBUG] Success - Message sent with recId:", data.recId);
      return {
        ok: true,
        message: "OTP sent successfully via shared service",
        code,
        statusCode: response.status,
      };
    } else {
      console.log("[SMS SHARED DEBUG] Failed - Response:", data);
      const message = (data && (data.status || data.message)) || `Failed to send OTP via shared service (Status: ${response.status})`;
      return {
        ok: false,
        message,
        statusCode: response.status,
      };
    }
  } catch (error) {
    console.error("[SMS SHARED DEBUG] Melipayamak shared API error:", error);
    return { ok: false, message: "SMS shared service unavailable", statusCode: 502 };
  }
}
